1. 建立时间 Tsu & 保持时间 Th
1.1 定义
建立时间 Tsu：在捕获沿（通常是上升沿）到来之前，数据输入必须已经稳定不变的最小时间。
保持时间 Th：在捕获沿到来之后，数据输入必须继续维持稳定的最小时间。
二者共同构成了触发器输入的“采样窗口”——只有数据在窗口期内纹丝不动，才能确保 Q 端输出合法逻辑值，否则可能采到中间电平甚至进入亚稳态。
1.2 时序方程（单周期路径）
设：
Tclk   = 时钟周期
Tcq    = 发起触发器 CK→Q 延迟
Tcomb  = 组合逻辑与布线延迟
Tskew  = 捕获沿相对发起沿的时钟网络延迟差（可正可负）
Tsu/Th = 库文件给出的触发器固有参数
则
建立约束：
(Tcq + Tcomb)max ≤ Tclk + Tskew – Tsu
左边是“数据到达时间”，右边是“数据需求时间”。
保持约束：
(Tcq + Tcomb)min ≥ Th + Tskew
保证“新数据”别来得太早，冲掉“老数据”。
1.3 违例后果
Setup 违例 → 采样失败，功能直接出错；提高时钟频率时最先遇到。
Hold 违例 → 同一时钟沿“冲掉”旧数据，可能引发亚稳态；与频率无关，只能靠综合/布线修正。
1.4 工程对策
Table
Copy
问题类型	常用手段
建立余量不足	降频、流水线切分、减少组合逻辑、换高速单元、有用 skew（时钟树微调）
保持余量不足	插入缓冲器（delay cell）、换慢速单元、增大 Tcomb、降低 skew
2. 亚稳态 Metastability
2.1 物理机理
触发器内部节点在采样瞬间若恰好落在 0/1 阈值区间（VL~VH），将长时间悬停在中间电平，既非 0 也非 1，这就是亚稳态。其恢复时间 tREC 呈指数分布，理论上可无限长，但概率随时间指数下降。
2.2 触发条件
输入在 Tsu-Th 窗口内跳变（典型场景：异步信号、CDC、时钟漂移）。
噪声/串扰导致阈值区间被“推”向数据边沿。
2.3 危害
输出停留在中间电平 → 后续组合逻辑产生毛刺或短路电流。
输出在 tREC 之后才翻转为确定值，但“0/1”结果不可预测 → 系统进入非法状态，甚至死锁。
2.4 量化指标——MTBF
MTBF = e^(tREC/τ) / (fCLK × fDATA × T0)
其中 τ、T0 为工艺常数。提高 tREC（留出更多决断时间）可指数级降低失效率，这是同步器设计的理论依据。
2.5 常见防护
单 bit 异步信号：至少两级触发器级联（“双锁存”），中间无组合逻辑；平均失效时间可从毫秒级提到千年级。
多 bit 控制/数据总线：使用格雷码、异步 FIFO、握手协议 (REQ/ACK) 或 MUX 同步器，确保“同一时刻只有 1 bit 翻转”或“数据已稳定再采样”。
复位域：采用“异步复位、同步释放”电路，避免复位释放在不同触发器上散开导致亚稳态。
3. 时钟域跨越 CDC
3.1 场景
现代 SoC/FPGA 常见“多时钟域”：
高频核心 & 低速外设
动态变频/门控时钟
第三方 IP 自带独立时钟
只要数据从时钟域 A 进入时钟域 B，且 A/B 频率/相位关系不固定，就存在 CDC 点。
3.2 CDC 带来的三大问题
亚稳态（已述）。
数据收敛：多 bit 总线各 bit 被不同捕获沿采样，导致“中间态”被下游逻辑误用。
数据丢失/重采样：快域到慢域时，脉冲宽度 < 慢域周期，信号被“跳过”。
3.3 设计原则
“单 bit 信号打两拍，多 bit 信号用 FIFO”——最简记忆口诀。
任何跨时钟路径必须在约束里声明为 set_clock_groups -asynchronous 或 set_false_path 的例外，防止综合工具盲目优化。
禁止在 CDC 路径插入组合逻辑；禁止用双边沿采样。
对快→慢传输，采用“脉冲展宽 + 握手”或异步 FIFO；对慢→快，可直接双锁存。
仿真阶段用专用 CDC 工具（SpyGlass、Questa CDC）做结构检查，结合协议验证。
3.4 常用同步器拓扑
Table
Copy
类型	适用场景	关键特征
双触发器	单 bit 电平/脉冲	面积小，MTBF 够用，需确保脉冲宽度 ≥ 源时钟周期
三触发器	高可靠性、高温/高辐射	进一步指数级降低失效率
异步 FIFO	多 bit 数据流	用格雷码比较读写地址，空满标志跨域，一次性解决“数据+控制”同步
MUX 同步器	多 bit 配置寄存器	源域先寄存，目的域用 MUX 选择“稳定副本”，保证无中间态
握手（REQ-ACK）	低带宽控制信号	四相位或两相位协议，硬件开销小，带宽低




每个有效时钟沿（通常是上升沿）触发器就执行一次采样-锁存：
拍照 → 保持 → 下一沿再拍，循环往复。
所以数据更新频率 = 时钟频率，一拍一次，绝不重复也绝不遗漏。



详细解释 快→慢时钟时，数据宽度可能“被吞掉”(脉冲太窄，慢时钟根本采不到)
快→慢时钟“吞脉冲”本质：
快时钟域里只持续 1 个快周期的单周期脉冲，在慢时钟眼里可能完全落在它的采样窗口之外，于是慢 FF 一次也采不到，好像被“吞掉”了。
一、时间轴举例
快时钟 clk_f 周期 10 ns，脉冲 P 只在 t=0→10 ns 拉高；
慢时钟 clk_s 周期 50 ns，上升沿出现在 t=30 ns、80 ns…
| 信号   | 0 10 20 30 40 50 60 70 80 …(ns)
| P      | ‑‑|¯¯|‑‑ …
| clk_s  | ‑‑‑‑‑|‑‑‑‑‑|‑‑‑‑‑ …
P 高电平 10 ns，两端沿都不在 clk_s 的 Setup/Hold 窗口内；
慢 FF 在 t=30 ns 看到的是稳定低电平 → Q 保持 0；
结果：快域里明明产生了“一件事”，慢域却永远不知道。
二、为什么会落窗
两时钟异步，相位差任意；
脉冲宽度 < 慢周期 − 2×窗口(Setup+Hold)；
即使脉冲宽等于慢周期，也可能因为 setup 违规而被错过；
真正能被慢时钟“ guaranteed 采到”的最小脉冲宽 =
T_slow − (Tsu + Th) ≈ 一个慢周期减去采样窗口。
三、工程解决思路
展宽
快域里检测到事件后把脉冲拉成至少 1.5×T_slow 的高电平，再用慢时钟双 flop 同步，最后快域收到“已取”反馈才拉低。
代价：延迟增加、需握手线。
握手机制
快域置位 req→慢域同步 req→慢域处理→慢域回 ack→快域同步 ack→快域清 req。
保证无论快慢，每次事件都唯一对应一次完整握手。
异步 FIFO
把事件写成数据包推入 FIFO，快域写指针 Gray 码跨到慢域，慢域按自己速率读取。
适合连续数据流，面积稍大但最可靠。
电平转换而非脉冲
若事件频率远低于慢时钟，可把“事件”变成电平翻转，慢域用边沿检测；电平可持续几千个快周期，确保必被采到。
一句话总结
快时钟的“一闪”脉冲比慢时钟的采样窗口还短，两者相位又任意，于是脉冲可能完全躲过后者的“快门”，看上去就像被吞掉；
解决原则：展宽到慢周期以上、或改用握手/FIFO、或用电平信号+边沿检测，确保慢域至少能“看见”一次。
