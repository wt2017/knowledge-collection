[TAP 控制器物理实现]
┌───────────────────────────────────────────┐
│ 芯片内部 (MPC8548)                        │
│                                           │
│  ┌──────────────────────────────────┐    │
│  │ TAP 控制器 (硬核)                 │    │
│  │                                  │    │
│  │  ┌──────────────┐               │    │
│  │  │ 状态机寄存器  │ ←─ TMS        │    │
│  │  │ (4-bit DFF)  │ ←─ TRST       │    │
│  │  └──────┬───────┘               │    │
│  │         │ 解码逻辑               │    │
│  │  ┌──────▼───────┐               │    │
│  │  │ IR (4-bit)   │ ←─ TDI        │    │
│  │  │ 移位+锁存    │ →─ TDO        │    │
│  │  └──────┬───────┘               │    │
│  │         │                       │    │
│  │  ┌──────▼───────┐               │    │
│  │  │ DR 多路选择器 │               │    │
│  │  │ (选通不同 DR) │               │    │
│  │  └──────┬───────┘               │    │
│  └─────────┼───────────────────────┘    │
│            │                             │
│  ┌─────────▼──────────────────────┐     │
│  │  CPU 核心 (e500v2)              │     │
│  │                                 │     │
│  │  ┌─────────────────┐            │     │
│  │  │ 调试寄存器组     │ ◄─────────┘     │
│  │  │ (DBCR, IAC, DAC)│ (由 JTAG 控制)  │
│  │  └─────────────────┘                 │
│  └──────────────────────────────────────┘
└───────────────────────────────────────────┘

┌─────────────────────────────────┐
│         TAP 控制器 FSM           │
│  ┌──────────────┐               │
│  │ 状态寄存器    │ ← TMS 解码逻辑  │
│  │ (4-bit)      │ ← TRST 异步复位 │
│  └──────┬───────┘               │
│         │                       │
│  ┌──────▼───────┐    ┌───────────▼─────────┐
│  │ IR 控制逻辑  │    │ DR 控制逻辑         │
│  │              │    │                     │
│  │ 控制信号     │    │ 选择器              │
│  │ - ShiftIR    │    │ - 选通哪个 DR        │
│  │ - UpdateIR   │    │ - 控制扫描路径       │
│  │ - ClockIR    │    └───────────┬─────────┘
│  └──────┬───────┘                │
│         │                        │
│  ┌──────▼────────────────────────▼────────┐
│  │      JTAG 寄存器组 (IR + DRs)          │
│  └────────────────────────────────────────┘
└───────────────────────────────────────────┘

工作原理：
每个 TCK 上升沿，TMS 被采样，状态机可能转换状态
状态转换产生控制信号（如 ShiftIR, UpdateDR）
控制信号驱动寄存器操作：
ShiftIR=1：每个 TCK 上升沿，IR 移位寄存器右移，TDI→MSB，LSB→TDO
UpdateIR=1：在 Exit1-IR→Update-IR 转换时，将移位寄存器锁存到指令寄存器

为什么 TAP 能在 CPU 不工作时运行？
独立时钟：TCK 可由调试器提供，不依赖 CPU 核心时钟
独立复位：TRST 仅复位 TAP 逻辑，不复位 CPU
组合逻辑：状态转换是硬编码的，无需软件配置
硅片固化：状态机逻辑在芯片设计时烧录，上电即存在

[TAP 状态机]
Test-Logic-Reset (初始状态)
    ↓ TMS=0
Run-Test/Idle
    ↓ TMS=1
Select-DR-Scan
    ↓ TMS=0      ↓ TMS=1
Capture-DR ←─── Select-IR-Scan
    ↓ TMS=0      ↓ TMS=0
Shift-DR ←───┐   Capture-IR
    ↓ TMS=1  │     ↓ TMS=0
Exit1-DR   │   Shift-IR ←───┐
    ↓ TMS=0  │     ↓ TMS=1  │
Pause-DR   │   Exit1-IR   │
    ↓ TMS=1  │     ↓ TMS=0  │
Exit2-DR ──┘   Pause-IR   │
    ↓ TMS=0      ↓ TMS=1  │
Update-DR      Exit2-IR ──┘
                 ↓ TMS=0
               Update-IR
                 ↓
              (返回 Run-Test/Idle)

Reset 状态：Test-Logic-Reset，TAP 逻辑复位
Idle 状态：Run-Test/Idle，空闲等待
IR 访问状态：Select-IR-Scan → Capture-IR → Shift-IR → Update-IR
DR 访问状态：Select-DR-Scan → Capture-DR → Shift-DR → Update-DR
| 状态                   | 功能                           | romInit 调试中的应用           |
| -------------------- | ---------------------------- | ------------------------ |
| **Test-Logic-Reset** | 异步复位 TAP 逻辑，初始化所有寄存器         | **上电后强制进入**，确保 JTAG 逻辑干净 |
| **Run-Test/Idle**    | 主空闲状态，执行测试或等待命令              | 两次扫描之间的安全等待点             |
| **Capture-IR**       | 将指令寄存器的固定值（如 IDCODE）加载到移位寄存器 | 验证 IR 链完整性               |
| **Shift-IR**         | 通过 TDI→TDO 移入新指令             | **加载 DEBUG\_COMMAND 指令** |
| **Update-IR**        | 将移位寄存器内容锁存到指令寄存器             | **指令生效的关键状态**            |
| **Capture-DR**       | 捕获数据寄存器的当前值到移位寄存器            | 读取 CPU 寄存器前准备            |
| **Shift-DR**         | 数据输入/输出的实际移位操作               | **读写寄存器/内存的核心状态**        |
| **Update-DR**        | 将移位数据锁存到数据寄存器（影响硬件）          | **写入寄存器生效的关键**           |


IR 值 | 指令 | 功能
------|------|-------------------
0000  | EXTEST | 边界扫描测试
0010  | SAMPLE | 采样引脚状态
1000  | ABORT | 中止调试操作 (ARM)
1010  | DEBUG_COMMAND | PowerPC 调试命令
1110  | IDCODE | 读取芯片 ID
1111  | BYPASS | 旁路器件 (1-bit 延迟)

| DR 名称          | 长度     | IR 选择    | 功能           |
| -------------- | ------ | -------- | ------------ |
| **BYPASS**     | 1-bit  | 0xF      | 旁路寄存器        |
| **IDCODE**     | 32-bit | 0xE      | 设备识别码        |
| **BOUNDARY**   | 可变     | 0x0, 0x2 | 边界扫描链        |
| **DEBUG**      | 可变     | 0xA      | PowerPC 调试接口 |
| **DEVICE\_ID** | 32-bit | 厂商定义     | 扩展识别         |
| **USERCODE**   | 32-bit | 厂商定义     | 用户自定义        |


[边界扫描链]
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ 引脚 1       │◄───►│ 边界扫描单元 │◄───►│ 引脚 2       │
│ (TDI)        │     │ (Cell 1)     │     │ (TDO)        │
└──────────────┘     └──────┬───────┘     └──────────────┘
                           │
┌──────────────┐     ┌──────▼───────┐     ┌──────────────┐
│ 引脚 783     │◄───►│ 边界扫挫单元 │◄───►│ 引脚 782     │
│ (GPIO)       │     │ (Cell 783)   │     │ (HRESET)     │
└──────────────┘     └──────┬───────┘     └──────────────┘
                           │
                    ┌──────▼───────┐
                    │  TAP 控制器  │
                    │  (控制所有)  │
                    └──────────────┘
每个边界扫描单元包含：
Capture 寄存器：锁存引脚当前状态
Shift 寄存器：串行移位数据
Update 寄存器：驱动引脚输出
Mode 选择器：选择功能模式或测试模式

# 测量所有地址/数据总线引脚的实际电平
# 验证 PCB 焊接是否短路或开路
> jtag irscan 0x0  # EXTEST
> jtag drscan 783 0x00...  # 设置所有引脚为输入
> jtag drscan 783 0x00...  # 读取 783 个引脚状态
# 分析：若某地址线恒为 0 → 可能对地短路

[Debug 数据寄存器（MPC8548 专用）]
┌─────────┬──────────────┬──────────────────┬──────────────┐
│ 操作码  │ 核心选择     │ 寄存器地址/数据  │ 保留/状态    │
│ (8-bit) │ (4-bit)      │ (32-bit)         │ (12-bit)     │
└─────────┴──────────────┴──────────────────┴──────────────┘
操作码：
0x01: READ_SPR
0x02: WRITE_SPR
0x03: READ_MEM
0x04: WRITE_MEM
0x05: HALT_CORE
0x06: RESUME_CORE
0x07: RESET_CORE
0x08: READ_DBCR
0x09: WRITE_DBCR

举例：设置硬件断点
# 在地址 0xFFFFFFFC 设置指令地址断点 (IAC1)
# 1. 写 IAC1 寄存器 (SPR 312)
> jtag irscan 0xA  # DEBUG_COMMAND
> jtag drscan 56 0x02001380000000  # 操作码=0x02, 寄存器=312, 数据=0xFFFFFFFC

# 2. 使能断点，写 DBCR0 (SPR 308)
> jtag drscan 56 0x02001344020000  # 操作码=0x02, 寄存器=308, 数据=0x42000000
# DBCR0 = 0x42000000 (IAC1US=1, IAC1ER=1, EDM=1)

# 3. 恢复 CPU 执行
> jtag drscan 56 0x05000000000000  # 操作码=0x05 (HALT_CORE)，但 Halt=0 表示恢复

# 4. CPU 运行到 0xFFFFFFFC 时自动暂停
#    JTAG 状态自动切换到 Stopped

[IR & DR 协同工作流程：以读取 CPU 寄存器为例]
步骤 1: 复位 TAP (确保从 Test-Logic-Reset 开始)
TMS: 1-1-1-1-1 (至少 5 个 TCK 高电平)
状态转换: Test-Logic-Reset → Test-Logic-Reset

步骤 2: 进入 Shift-IR 状态
TMS: 0-1-1-0-0
状态转换: Test-Logic-Reset → Run-Test/Idle → Select-DR-Scan → Select-IR-Scan → Capture-IR → Shift-IR

步骤 3: 移入 DEBUG_COMMAND 指令 (4-bit)
TDI: 1-0-1-0 (0xA, LSB first)
TMS: 0-0-0-1 (前 3 个 bit 保持 0，最后 1 个 bit 为 1 表示退出 Shift-IR)
状态转换: Shift-IR → Exit1-IR

步骤 4: 更新指令寄存器
TMS: 1-0
状态转换: Exit1-IR → Update-IR → Run-Test/Idle
此时 IR = 0xA 生效

步骤 5: 进入 Shift-DR 状态
TMS: 1-1-0-0
状态转换: Run-Test/Idle → Select-DR-Scan → Capture-DR → Shift-DR

步骤 6: 移入具体操作命令 (56-bit)
TDI: 56-bit 命令 (LSB first)
TMS: 0...0-1 (前 55 个 bit 为 0，最后 1 个 bit 为 1)
状态转换: Shift-DR → Exit1-DR

步骤 7: 更新数据寄存器
TMS: 1-0
状态转换: Exit1-DR → Update-DR → Run-Test/Idle
此时命令被执行

步骤 8: 捕获返回数据
TMS: 1-1-0
状态转换: Run-Test/Idle → Select-DR-Scan → Capture-DR
此时 DR 已加载返回数据

步骤 9: 移出返回数据 (56-bit)
TMS: 0...0-1
TDO: 56-bit 返回数据 (LSB first)
状态转换: Shift-DR → Exit1-DR → Update-DR → Run-Test/Idle


[从 JTAG 上电到 romInit 调试的完整流程]
1. [上电前] 确保 TRST 拉低，HRESET 拉低
2. 目标板上电，测量电源轨稳定
3. 释放 HRESET (保持 TRST 低)
4. 连接 JTAG 调试器

[JTAG 初始化]
5. 调试器发送 TCK 脉冲，TMS 持续为高 (至少 5 个周期)
   → TAP 强制进入 Test-Logic-Reset
6. 调试器读取 IDCODE
   a) IRSCAN: 0xE (IDCODE 指令)
   b) DRSCAN: 32 (读取 IDCODE)
   c) 返回: 0x2083401D (确认 MPC8548E)
7. 调试器加载调试配置
   a) IRSCAN: 0xA (DEBUG_COMMAND)
   b) DRSCAN: 0x05000000000000 (暂停 CPU)

[romInit 调试]
8. 在 0xFFFFFFFC 设置硬件断点
   a) IRSCAN: 0xA
   b) DRSCAN: 0x02001380FFFFFFFC (IAC1 = 复位向量)
   c) DRSCAN: 0x0200134402000000 (DBCR0 使能断点)
9. 释放 TRST
10. CPU 从 0xFFFFFFFC 取指
11. 硬件断点匹配，CPU 暂停
12. 调试器通过 JTAG 读取所有寄存器
    a) 反复执行 READ_SPR 命令
    b) DR 返回 r0, r1, ..., pc, msr
13. 开发者单步执行 romInit
    a) 每条指令后读取相关寄存器
    b) 监控 DDR/Cache 配置寄存器
14. 发现 DDR 配置错误，修改代码重试
15. DDR 初始化成功，系统跳转到 RAM
16. 切换到软件断点，继续应用层调试
